/*
Jordan Dehmel
jdehmel@outlook.com
github.com/jorbDehmel
2023 - present
GPLv3 held by author
*/

#include "document.hpp"

const std::string rule = "------------------------------";
const std::string headerStart = "# ";
const std::string fileStart = "## ";
const std::string fnStart = "### ";

void generate(const std::vector<std::string> &Files, const std::string &Output)
{
    if (Files.size() == 0)
    {
        return;
    }

    auto start = std::chrono::high_resolution_clock::now();

    std::ofstream out(Output);
    if (!out.is_open())
    {
        throw std::runtime_error("Failed to open file '" + Output + "'");
    }

    // File header
    out << headerStart << Output << "\n\n"
        << "Generated by Acorn from source files:\n";

    for (auto fileName : Files)
    {
        out << " - " << fileName << '\n';
    }

    auto curTime = time(NULL);
    out << ctime(&curTime) << '\n';

    // Iterate over files
    for (auto fileName : Files)
    {
        // Insert header
        out << rule << '\n' << fileStart << fileName << "\n\n";

        std::map<std::string, std::string> data;
        std::vector<std::string> lines;
        std::string line;

        // Load file
        std::ifstream file(fileName);
        if (!file.is_open())
        {
            throw std::runtime_error("Failed to open file '" + fileName + "'");
        }

        while (getline(file, line))
        {
            lines.push_back(line);
        }

        file.close();

        // Scan and build data
        std::string mostRecentComment = "";
        for (int i = 0; i < lines.size(); i++)
        {
            if (lines[i].size() >= 2 && lines[i].substr(0, 2) == "//")
            {
                // Single line comment
                mostRecentComment += lines[i].substr(3) + "\n";
            }
            else if (lines[i].size() >= 2 && lines[i].substr(0, 2) == "/*")
            {
                // Multi-line comment
                while (lines[i].size() < 2 || lines[i].substr(0, 2) != "*/")
                {
                    mostRecentComment += lines[i] + "\n";
                    i++;
                }

                // Erase the begin comment
                mostRecentComment.erase(0, 2);

                // Erase the end comment
                mostRecentComment.pop_back();
                mostRecentComment.pop_back();
            }
            else if (lines[i] == "{")
            {
                // Code scope; Skip to end

                int count = 0;
                do
                {
                    if (lines[i] == "{")
                    {
                        count++;
                    }
                    else if (lines[i] == "}")
                    {
                        count--;
                    }

                    i++;
                } while (i < lines.size() && count != 0);

                // Reset commenting
                mostRecentComment = "";
            }
            else
            {
                if (lines[i].find("!") == std::string::npos)
                {
                    // Add to data
                    data[lines[i]] = mostRecentComment;
                }

                // Reset commenting
                mostRecentComment = "";
            }
        }

        // Reconstruct into output document
        for (std::pair<std::string, std::string> cur : data)
        {
            out << fnStart << cur.first << "\n\n";

            if (cur.second == "")
            {
                std::cout << "(No documentation was provided)\n\n";
            }
            else
            {
                out << cur.second << "\n\n";
            }
        }
    }

    auto end = std::chrono::high_resolution_clock::now();
    unsigned long long elapsedNS = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

    out << rule << "\n\n"
        << "Generation took " << elapsedNS << " ns, about " << ((double)elapsedNS / Files.size()) << " ns / file.\n";

    out.close();

    return;
}
