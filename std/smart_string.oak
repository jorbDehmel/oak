////////////////////////////////////////////////////////////////

/*
A basic self-resizing heap string for Oak.

As of now, this is experimental, but once refined, it will
replace the existing std/string.oak.

Jordan Dehmel, 2024
jdehmel@outlook.com
*/

////////////////////////////////////////////////////////////////

package!("std");
use_rule!("std");

let string: struct
{
    capacity: u128,
    current_length: u128,
    data: []i8,
}

////////////////////////////////////////////////////////////////

let New(self: ^string) -> void
{
    self.capacity = 0;
    self.current_length = 0;
    ptrcpy!(self.data, 0);
}

let Del(self: ^string) -> void
{
    if self.capacity != 0
    {
        free!(self.data);
    }

    self.capacity = 0;
    self.current_length = 0;
    ptrcpy!(self.data, 0);
}

////////////////////////////////////////////////////////////////

// Doubles the current capacity. If 0, sets to 8.
let Expand(self: ^string) -> void
{
    if self.capacity == 0
    {
        self.capacity = 8;
        alloc!(self.data, self.capacity);
    }
    else
    {
        // Get old data
        let old: ^i8;
        ptrcpy!(old, self.data);

        // Allocate new space
        self.capacity *= 2;
        alloc!(self.data, self.capacity);

        // Copy over old data
        strcpy(new, old);

        // Free old data
        free!(old);
    }
}

// Halves the current capacity.
let Shrink(self: ^string) -> void
{
    if self.capacity > 7
    {
        // Get old data
        let old: ^i8;
        ptrcpy!(old, self.data);

        // Allocate new space
        self.capacity /= 2;
        alloc!(self.data, self.capacity);

        // Copy over old data
        strncpy(self.data, old, self.capacity);
        ptrarr!(self.data, self.capacity - 1) = 0;

        // Free old data
        free!(old);

        // Find new size
        self.current_length = strlen(self.data);
    }
}

// If needed, expands to the given size. If the current size is
// already equal to or larger than the given one, does nothing.
let reserve(self: ^string, size: u128) -> void
{
    if self.capacity < size
    {
        // Get old data
        let old: ^i8;
        ptrcpy!(old, self.data);

        // Allocate new space
        self.capacity = size;
        alloc!(self.data, self.capacity);

        // Copy over old data
        strcpy(new, old);

        // Free old data
        free!(old);
    }
}

// Sets the current capacity to 0. Equivalent to Del(self)
let clear(self: ^string) -> void
{
    if self.capacity != 0
    {
        free!(self.data);
    }

    self.capacity = 0;
    self.current_length = 0;
    ptrcpy!(self.data, 0);
}

////////////////////////////////////////////////////////////////

let Copy(self: ^string, from: str) -> void
{
    let new_size = strlen(from);
    while self.capacity < new_size
    {
        self.Expand();
    }

    strcpy(self.data, from);
}

let Copy(self: ^string, other: string) -> void
{
    self.reserve(other.capacity);
    strcpy(self.data, other.data);
}

let Copy(self: ^string, other: []i8) -> void
{
    let new_size = strlen(from);
    while self.capacity < new_size
    {
        self.Expand();
    }

    strcpy(self.data, from);
}

let AddEq(self: ^string, other: string) -> void
{
    let new_size = self.current_length + other.current_length;

    while self.capacity < new_size
    {
        self.Expand();
    }

    let i: u128 = 0;
    while self.current_length + i < new_size
    {
        ptrarr!(self.data, self.current_length + i) = ptrarr!(other.data, i);
        i += 1;
    }

    self.current_length += i;
}

let AddEq(self: ^string, other: str) -> void
{
    let new_size = self.current_length + strlen(other);

    while self.capacity < new_size
    {
        self.Expand();
    }

    let i: u128 = 0;
    while self.current_length + i < new_size
    {
        ptrarr!(self.data, self.current_length + i) = ptrarr!(other, i);
        i += 1;
    }

    self.current_length += i;
}

let AddEq(self: ^string, other: []i8) -> void
{
    let new_size = self.current_length + strlen(other);

    while self.capacity < new_size
    {
        self.Expand();
    }

    let i: u128 = 0;
    while self.current_length + i < new_size
    {
        ptrarr!(self.data, self.current_length + i) = ptrarr!(other, i);
        i += 1;
    }

    self.current_length += i;
}

let Add(a: string, b: string) -> string {}

let Add(a: string, b: str) -> string {}

let Add(a: string, b: []i8) -> string {}

let Get(self: ^string, index: u128) -> i8 {}

////////////////////////////////////////////////////////////////

let Eq(a: string, b: string) -> bool
{
    strcmp(a.data, b.data) == 0
}

let Eq(a: string, b: str) -> bool
{
    strcmp(a.data, b) == 0
}

let Eq(a: string, b: []i8) -> bool
{
    strcmp(a.data, b) == 0
}

let Neq(a: string, b: string) -> bool
{
    Not(Eq(a, b))
}

let Neq(a: string, b: str) -> bool
{
    Not(Eq(a, b))
}

let Neq(a: string, b: []i8) -> bool
{
    Not(Eq(a, b))
}

let is_substring_eq(
    self: ^string,
    what: str,
    start: u128,
    n: u128) -> bool
{
}

let is_substring_eq(
    self: ^string,
    what: []i8,
    start: u128,
    n: u128) -> bool
{
}

/*
Returns true if and only if all the characters from
self[my_start] to self[my_start + n] match all that characters
from other[other_start] to other[other_start + n]. If my_start
or my_start + n are larger than self.current_length, returns
false. Similarly, returns false if other_start or
other_start + n is greater than other.current_length.
*/
let is_substring_eq(
    self: ^string,
    other: string,
    my_start: u128,
    other_start: u128,
    n: u128) -> bool
{
}

////////////////////////////////////////////////////////////////

let print(what: string) -> void
{
    print(what.data);
}

/*
Uses DJB2 by Dan Bernstein
http://www.cse.yorku.ca/~oz/hash.html
*/
let hash(what: ^string) -> u128
{
    let out: u128 = 5 381;
    let cur: i8 = 0;

    let i: u128 = 0;
    while i < self.size
    {
        cur = ptrarr!(self.data, i);

        out *= 33;
        out += cur;

        i += 1;
    }

    if out == to_u128(0)
    {
        out = 1;
    }

    out
}

let size(what: ^string) -> u128
{
    self.current_length
}

let empty(what: ^string) -> bool
{
    self.current_length == 0
}

////////////////////////////////////////////////////////////////
